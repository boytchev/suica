
var _vector1=new THREE.Vector3();var _vector2=new THREE.Vector3();class CSGCuttingPlane extends THREE.Plane{constructor(normal,constant){super(normal,constant);}
fromPoints(a,b,c){const normal=b.subVectors(b,a).cross(_vector2.subVectors(c,a)).normalize();this.normal=normal;this.constant=normal.dot(a);return this;}
setFromCoplanarPoints(a,b,c){var normal=_vector1.subVectors(c,b).cross(_vector2.subVectors(a,b)).normalize();this.setFromNormalAndCoplanarPoint(normal,a);return this;}
setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this;}
clone(){return new CSGCuttingPlane().copy(this);}
copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this;}
negate(){this.constant*=-1;this.normal.negate();return this;}
splitPolygon(polygon,coplanarFront,coplanarBack,front,back){const COPLANAR=0;const FRONT=1;const BACK=2;const SPANNING=3;const EPSILON=1e-5;let polygonType=0;const types=[];for(let i=0;i<polygon.vertices.length;i++){const t=this.normal.dot(polygon.vertices[i].pos)-this.constant;const type=t<-EPSILON?BACK:t>EPSILON?FRONT:COPLANAR;polygonType|=type;types.push(type);}
switch(polygonType){case COPLANAR:(this.normal.dot(polygon.plane.normal)>0?coplanarFront:coplanarBack).push(polygon);break;case FRONT:front.push(polygon);break;case BACK:back.push(polygon);break;case SPANNING:const f=[];const b=[];for(let i=0;i<polygon.vertices.length;i++){const j=(i+1)%polygon.vertices.length;const ti=types[i];const tj=types[j];const vi=polygon.vertices[i];const vj=polygon.vertices[j];if(ti!=BACK)f.push(vi);if(ti!=FRONT)b.push(ti!=BACK?vi.clone():vi);if((ti|tj)==SPANNING){const t=(this.constant-this.normal.dot(vi.pos))/this.normal.dot(vj.pos.clone().sub(vi.pos));const v=vi.interpolate(vj,t);f.push(v);b.push(v.clone());}}
if(f.length>=3){const p=new CSGPolygon(f);front.push(p);}
if(b.length>=3){const p=new CSGPolygon(b);back.push(p);}
break;}}}